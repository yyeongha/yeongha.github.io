---
title: AI-DX education 3조_알약 프로젝트 실패기록 (test_code2)
categories: [Project] 
date: 2024-06-10
last_modified_at: 2024-06-10
---
# 1. data
## 1) data 폴더 구조
📦test_code2
 ┣ 📂data
 ┃ ┣ 📂images # 원본 이미지 
 ┃ ┣ 📂labels # 원본 라벨
 ┃ ┣ 📂dataset
 ┃ ┃ ┣ 📂test
 ┃ ┃ ┃ ┣ 📂images
 ┃ ┃ ┃ ┗ 📂labels
 ┃ ┃ ┣ 📂train
 ┃ ┃ ┃ ┣ 📂images
 ┃ ┃ ┃ ┗ 📂labels
 ┃ ┃ ┗ 📂valid
 ┃ ┃ ┃ ┣ 📂images
 ┃ ┃ ┃ ┗ 📂labels
 ┃ ┗ 📂database
 ┃ ┃ ┗ 📜pills_info.csv


## 2) 데이터 수집 방법
### (1) aihub
* 경구약제 이미지 데이터
https://www.aihub.or.kr/aihubdata/data/view.do?currMenu=&topMenu=&aihubDataSe=data&dataSetSn=576

* 166.약품식별 - 01.데이터 - 원천데이터 - 단일경구약제5000종 - TS_51단일.zip 다운

* TS_51단일.zip 을 까서 프로젝트에 필요한 약만 남기고 삭제
![TL_51]()
-> D:\3조_의약품\dataset\data_test2\원천_단일 경구약제 이미지 데이터_51_59\01.데이터\1.Training\원천데이터\단일경구약제 5000종\TS_51_단일 \
이 경로에 있음

* TS_51_단일 파일에서 각 약당 한개의 사진만 있는 폴더를 만듦 (원천_jpg_51)
-> D:\3조_의약품\dataset\data_test2\원천_jpg_51 \
이 경로에 있음

-> 이 폴더를 만든 이유는 roboflow에서 라벨링 작업을 할건데 각 약 폴더에 조명, 회전이 다른 약들이 있기 때문에 조명, 회전이 디폴트값인 약 사진 하나씩만 폴더에 넣었다.

?강사님에게 물어볼 질문? 
-> 모델을 학습시키려면 이미지와 라벨 데이터가 있어야 하는데, 우리 팀이 가지고 있는 이미지 데이터는 약 하나당 조명과 회전이 각각 다른 사진이 대략 20장씩 있다. 시간상 각 이미지를 라벨링을 못할 것 같은데, 각 약당 대표 이미지를 뽑아서 그것만 라벨링을 한 후 데이터 증강을 해서 모델을 학습시켜도 되는지? 

### (2) roboflow
* roboflow에서 이미지 데이터 자동 라벨링 후 데이터 증강
![roboflow]()


## 2) dataset
* roboflow에서 만든 데이터셋(train, valid, test)을 dataset폴더에 저장


## 3) database
### (1) aihub
* 166.약품식별 - 01.데이터 - 라벨링데이터 - 단일경구약제5000종 - TS_51단일.zip

* TS_51단일.zip 을 까서 프로젝트에 필요한 약만 남기고 삭제
![TL_51]()
-> D:\3조_의약품\dataset\data_test2\라벨링_단일_경구약제 이미지 데이터_51\01.데이터\1.Training\라벨링데이터\단일경구약제 5000종\TL_51_단일 \
이 경로에 있음

* TS_51단일.zip 을 까서 프로젝트에 필요한 약만 남기고 삭제
-> D:\3조_의약품\dataset\data_test2\라벨링_json_51
이 경로에 있음

* 위의 파일(json)들을 csv 파일로 dl_name을 기준으로 합쳤다.
-> pills_info.csv 파일
![pills_info]()


* pills_info.csv 파일을 프로젝트의 database 폴더에 넣음


# 2. models
## 1) models 폴더 구조

📦test_code2
┣ 📂models
 ┃ ┣ 📂yolov8
 ┃ ┃ ┗ 📜best.pt
 ┃ ┗ 📂resnet
 ┃ ┃ ┗ 📜best.pt

## 2) resnet 학습
### (1) colab => resnet_training.ipynb
```
from google.colab import drive
drive.mount('/content/drive')

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms, models
from torch.utils.data import DataLoader
```
```
# 데이터셋 로드
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
])

train_dataset = datasets.ImageFolder('/content/drive/MyDrive/Team3_pill/data/dataset/train/images', transform=transform)
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
```
```
# ResNet 모델 정의
class ResNet(nn.Module):
    def __init__(self, num_classes):
        super(ResNet, self).__init__()
        # pretrained=False 대신 weights=None 사용
        self.model = models.resnet18(weights=None)
        num_ftrs = self.model.fc.in_features
        self.model.fc = nn.Linear(num_ftrs, num_classes)

    def forward(self, x):
        return self.model(x)

# 클래스 수 설정
num_classes = 15  # 예시로 클래스 수를 15로 설정

# 모델 초기화
model = ResNet(num_classes=num_classes)
```
-> 지금 가지고 있는 train 데이터셋이 적어서 resnet18 사용함
-> 클래스 수 = 약의 갯수(약의 폴더 수)

```
# 손실 함수와 옵티마이저 정의
criterion = nn.CrossEntropyLoss() 
optimizer = optim.Adam(model.parameters(), lr=0.001) 
```
-> criterion : 모델의 출력(각 클래스에 대한 확률 분포)과 실제 정답 레이블을 비교하여 손실을 계산
-> optimizer : 옵티마이저를 사용하여 모델의 가중치를 업데이트할 방법을 설정. 학습률은 0.001로 설정

```
# 학습 루프
num_epochs = 10 # 전체 학습 반복 횟수를 10으로 설정
for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0 
    for images, labels in train_loader:
        optimizer.zero_grad() 
        outputs = model(images) 
        loss = criterion(outputs, labels) 
        loss.backward() 
        optimizer.step() 
        running_loss += loss.item() 

    print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {running_loss/len(train_loader)}")
```
-> num_epochs = 10 : 전체 학습 반복 횟수를 10으로 설정, 데이터 수가 적어서 높은 epoch으로 설정할 경우 과적합이 발생할 수 있기 때문에
-> running_loss = 0.0 : 한 에폭 동안 발생하는 총 손실 값을 누적하기 위한 변수를 초기화
-> optimizer.zero_grad() : 옵티마이저의 기울기(gradient)를 초기화
-> outputs = model(images) : 모델에 이미지 데이터(images)를 입력으로 넣어 예측값(outputs)을 얻음
-> loss = criterion(outputs, labels) : 손실 함수(criterion)를 사용하여 모델의 예측값(outputs)과 실제 정답 레이블(labels) 간의 차이를 계산하여 손실 값(loss)
-> loss.backward() : 역전파(backpropagation) 알고리즘을 통해 손실 값을 기반으로 각 가중치에 대한 기울기를 계산
-> optimizer.step() : 계산된 기울기를 사용하여 옵티마이저가 모델의 가중치를 업데이트
-> running_loss += loss.item() : 현재 배치의 손실 값을 running_loss에 누적하여 한 에폭 동안의 총 손실 값을 계산

```
# 모델 저장
torch.save(model.state_dict(), '/content/drive/MyDrive/Team3_pill/model/resnet/best.pt')
print("Model saved successfully!")
```

* 저장된 best.pt파일을 프로젝트의 model/resnet 폴더에 저장

## 3) yolov8 학습
### (2) colab => yolov8_training.ipynb


























---